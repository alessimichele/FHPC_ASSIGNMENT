#include <string.h>
#include <stdlib.h>
#include <stdio.h> 
#include <mpi.h>
#include <omp.h>
#include <time.h>

#include "io_init.h"

#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif


void parallel_write(unsigned char* grid, int maxval, char* file_path, int k, int my_rows_number, int rank, int size, MPI_Comm comm) {
    
    MPI_Status status;
    //initialize the variable header_offset in each process
    MPI_Offset header_offset;
    if (rank==0){
        FILE* file_stream; 

        file_stream = fopen(file_path, "w+"); //file is going to be either created or overwritten,
        // and the file pointer is positioned at the beginning of the file,
        //so the function ftell will return 0, which is the initial position of the file pointer

        int color_depth = 1 + ( maxval > 255 );
        
        if (file_stream != NULL){
            fprintf(file_stream, "P5\n# generated by\n# Alessi Michele and Carollo Marco\n%d %d\n%d\n", k, k, maxval);
            header_offset = ftell(file_stream);
            fclose(file_stream); 
        }else{
            fprintf(stderr, "Failed to open the PGM file for writing.\n");
        }
    }
    MPI_Barrier(comm);  
    
    MPI_File file;
    MPI_File_open(comm, file_path, MPI_MODE_WRONLY, MPI_INFO_NULL, &file);

    // Now broadcast the initial position (from rank 0, that got it with ftell) to all other processes
    MPI_Bcast(&header_offset, 1, MPI_OFFSET, 0, MPI_COMM_WORLD);
    MPI_Barrier(comm);
    //let's calculate the offset, first we need an array with the number of rows for each process
    int* rows_per_process = (int*)malloc(size*sizeof(int));
    for (int i=0; i<size; i++){
        rows_per_process[i] = (i<(k%size)) ? k/size +1 : k/size;
    }
    int* offset_arr = (int*)malloc(size*sizeof(int));
    offset_arr[0] = 0;
    for (int i=1; i<size; i++){
        offset_arr[i] = offset_arr[i-1] + rows_per_process[i-1]*k;
    }
    free(rows_per_process);

    MPI_Offset offset = offset_arr[rank]*sizeof(unsigned char)+header_offset;

    MPI_File_seek(file, offset, MPI_SEEK_SET);
    MPI_Barrier(comm);
    MPI_File_write(file, grid, my_rows_number * k, MPI_UNSIGNED_CHAR, &status);

    MPI_File_close(&file);
    free(offset_arr);
    return;
}


void init_parallel(char *file_path, int k, int rank, int size, int my_rows_number){

    unsigned char *partial_grid = (unsigned char*)malloc(k*my_rows_number*sizeof(unsigned char));
    
    if (partial_grid == NULL) {
      perror("Memory allocation error");
      return;
    }

    unsigned int seed = clock();
    seed = seed * rank;
   
    for (int i=0; i<my_rows_number*k; i++){
        partial_grid[i] = rand_r(&seed)%2 * 255;
    }

    parallel_write(partial_grid, 255, file_path, k, my_rows_number, rank, size, MPI_COMM_WORLD);
    free(partial_grid);
    return;
}

void parallel_read( unsigned char **grid_pointer, int *maxval, int *xsize, int *ysize,  char *file_path, int my_rows_number, int rank, int size, MPI_Comm comm) {
    
    MPI_Status status;
    //initialize the variable header_offset in each process
    MPI_Offset header_offset;
    if (rank==0){
       
        FILE* file_stream; 
        file_stream = fopen(file_path, "r"); 
        
        *xsize = *ysize = *maxval = 0;
        
        char    MagicN[2];
        char   *line = NULL;
        size_t  m, n = 0; // m is the number of characters read, n is the size of the buffer
        
        // get the Magic Number
        m = fscanf(file_stream, "%2s%*c", MagicN );
        header_offset+=3; //+3 because of the \n
        // skip all the comments
        //printf("header offset dopo magic number: %lld\n", header_offset);
        m = getline( &line, &n, file_stream);
        header_offset+=m;
    
        //printf("header offset: %lld\n", header_offset);
        while ( (m > 0) && (line[0]=='#') ){
            m = getline( &line, &n, file_stream);
            header_offset+=m;   
            //printf("header offset dopo commenti: %lld\n", header_offset);
        }
        if (m > 0)
          {
            m = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
            //maybe fix HEADER_OFFSET
            if ( m < 3 ){
                m = getline(&line,&n,file_stream);
                header_offset+=m;
                sscanf(line, "%d%*c", maxval);
            }
          }
        else
          {
            *maxval = -1;         // this is the signal that there was an I/O error
        			    // while reading the grid header
            free( line );
            return;
          }
        free( line );
        
    }
    MPI_Barrier(comm);  
    
    MPI_File file;
    MPI_File_open(comm, file_path, MPI_MODE_RDONLY, MPI_INFO_NULL, &file);

    // Now broadcast the initial position (from rank 0, that got it with ftell) to all other processes
    MPI_Bcast(&header_offset, 1, MPI_OFFSET, 0, MPI_COMM_WORLD);
    //printf("header offset: %lld\n", header_offset);
    //broadcast also xsize
    MPI_Bcast(xsize, 1, MPI_INT, 0, MPI_COMM_WORLD);
    
    *grid_pointer = (unsigned char*)malloc(*xsize*my_rows_number*sizeof(unsigned char));
    MPI_Barrier(comm);
    //let's calculate the offset, first we need an array with the number of rows for each process
    int* rows_per_process = (int*)malloc(size*sizeof(int));
    for (int i=0; i<size; i++){
        rows_per_process[i] = (i<(*xsize%size)) ? *xsize/size +1 : *xsize/size;
    }
    int* offset_arr = (int*)malloc(size*sizeof(int));
    offset_arr[0] = 0;
    for (int i=1; i<size; i++){
        offset_arr[i] = offset_arr[i-1] + rows_per_process[i-1]*(*xsize);
    }
    free(rows_per_process);

    MPI_Offset offset = offset_arr[rank]*sizeof(unsigned char)+header_offset;

    MPI_File_seek(file, offset, MPI_SEEK_SET);
    MPI_Barrier(comm);
    MPI_File_read(file, *grid_pointer, my_rows_number * (*xsize), MPI_UNSIGNED_CHAR, &status);


    MPI_File_close(&file);
    
    free(offset_arr);

    return;
}
